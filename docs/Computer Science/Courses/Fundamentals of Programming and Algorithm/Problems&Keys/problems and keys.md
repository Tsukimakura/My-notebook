###### 1. 假设某段C语言程序中定义了三个变量`a`、`b`和`c`并且三个变量都不为0，则表达式`a / b * c`和`a * c / b`是等价的，其值相同。(F)

- 根据C语言的算术运算规则，表达式 `a / b * c` 和 `a * c / b` 并不总是等价的，其值可能不同。主要原因在于整数除法的截断行为（如果变量是整数类型）和浮点数的精度问题。

1. **整数类型的情况**

	**示例**：假设 `a = 3`, `b = 2`, `c = 2`（都是整数）：
	
	- `a / b * c = (3 / 2) * 2 = 1 * 2 = 2`
	    
	- `a * c / b = (3 * 2) / 2 = 6 / 2 = 3`

2. **浮点类型的情况**

	如果变量 `a`、`b`、`c` 都是浮点类型（如 `float` 或 `double`），理论上两个表达式在数学上等价，但由于浮点运算的精度限制和舍入误差，实际计算结果可能有微小差异。例如，当 `a * c` 的值很大或很小时，可能导致精度损失。

###### 2. What is the output of the following program?

```c
int main()
{
      int  a = 2, b = -1, c = 2;
      if(a < b)
            if(b < 0)
                  c = 0;
      else  c++;
      printf("%d\n",c);
      return 0;
}
```

最终输出c的值是2没有改变。
本题考查C语言中else与if的配对规则：在C语言中，**else总是与同一作用域内最近的、尚未匹配的if语句匹配**。这个规则被称为"**最近匹配原则**"或"**dangling else问题**"的解决方案。


###### 3. Among the following statements which intend to define arrays, which one is wrong?

A. `int x[2][]={1,2,4,6}`;
B. `int m[][3]={1,2,3,4,5,6}`;
C. `int a[1][3]`;
D. `int x[2][2]={1,2,3,4}`;

key: A
在C语言中，定义多维数组时，只有第一维的大小可以省略（当有初始化列表时），但其他维度的大小必须明确指定。选项A中，`int x[2][]={1,2,4,6};` 的第二维为空，这是错误的，因为编译器无法确定第二维的大小，从而无法计算内存布局。

###### 4. 下列程序的输出结果是( )。

A. (6,6)

B. (3,6)

C. (6,12)

D. (3,3)

```c
# include <stdio.h>

int f(int n){
	static int k, s;
	n--;
	for(k=n; k>0; k--)
		s += k;
	return s;
}

int main(void){
	int k;
	k=f(3);
	printf("(%d,%d)", k, f(k));
	return 0;
}
```
key: B
**静态变量基本特点：**
1. 生命周期：程序运行期间一直存在
2. 只初始化一次，*默认初始化为0*
3. 存储位置：静态存储区（数据段）
**注意事项：**
- 可能使函数不可重入
- 增加内存占用
- 测试时需要特殊处理

###### 5. 关于C语言指针的运算：指针只有加减操作，没有乘除操作。指针可以加常数、减常数；相同类型的指针可以相加、相减。(F)

- 在C语言中，指针确实没有乘法和除法操作，但指针的加减操作是有限制的。指针可以加或减一个整数常数（表示移动指针到相邻内存位置），但相同类型的指针不能相加——指针相加是非法的，因为它在语义上没有意义（例如，两个地址相加无法得到有效地址）。相同类型的指针可以相减，得到的是两个指针之间的元素个数。