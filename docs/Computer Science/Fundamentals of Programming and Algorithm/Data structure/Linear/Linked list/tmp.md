## 第一阶段：基石构建 —— 指针与内存的艺术

**目标**：扫清链表学习中最大的拦路虎——指针与动态内存分配。

### 第 1 课：结构体与指针再入门

1. **结构体自引用**：为什么 struct Node 内部可以包含 struct Node* 指针？
    
2. **操作符辨析**：. 与 -> 的本质区别（何时解引用）。
    
3. **内存布局**：画图理解“节点”在内存中是什么样子的（数据域+指针域）。
    

### 第 2 课：堆内存管理（Heap）

1. **malloc 与 sizeof**：如何在堆上“凭空”变出一个节点。
    
2. **free 的重要性**：什么是内存泄漏？什么是悬空指针（Dangling Pointer）？
    
3. **栈 vs 堆**：局部变量节点（栈）与动态分配节点（堆）的生命周期差异。
    

---

## 第二阶段：单链表的“原生态”实现（无哨兵）

**目标**：掌握最原始的链表，体会手动处理边界条件的痛苦（这是进阶的基础）。

### 第 3 课：单链表的定义与创建

1. **头指针（Head Pointer）**：它不是节点，它只是一个指向首节点的指针变量。
    
2. **头插法（Head Insert）**：最简单的 
    
    ```
    O(1)O(1)
    ```
    
     插入。
    
    - 难点：需要修改 head 变量本身，涉及二级指针 Node **head 或函数返回 Node*。
        
3. **遍历与打印**：while(p != NULL) 循环范式。
    

### 第 4 课：查找与尾部插入

1. **按值查找**：返回节点指针或 NULL。
    
2. **尾插法（Tail Insert）**：
    
    - 痛点：每次都要从头遍历到尾，时间复杂度 
        
        ```
        O(N)O(N)
        ```
        
        。
        
    - 边界：如果链表是空的，尾插法需要特殊处理（改变 head）。
        

### 第 5 课：节点的删除（由浅入深）

1. **删除非头节点**：需要寻找前驱指针 prev。
    
2. **删除头节点**：逻辑完全不同，需要 head = head->next。
    
3. **实战练习**：实现一个 delete(List, target) 函数，体验大量的 if-else 边界判断。
    

---

## 第三阶段：工程化优化 —— 哨兵与尾指针

**目标**：引入设计模式，消除代码中的 if-else，让逻辑变得优雅。

### 第 6 课：引入虚拟头结点（Dummy Head）

1. **概念**：创建一个不存数据的节点作为永久车头。
    
2. **重构插入逻辑**：无论插在第几个位置，都有“前驱”，无需修改 Head 指针。
    
3. **重构删除逻辑**：删除第一个有效节点和删除中间节点代码完全一致。
    
4. **栈上哨兵 vs 堆上哨兵**：工程实现中的两种写法。
    

### 第 7 课：引入尾指针（Tail Pointer）

1. **目的**：将尾插法的时间复杂度从 
    
    ```
    O(N)O(N)
    ```
    
     降为 
    
    ```
    O(1)O(1)
    ```
    
    。
    
2. **结构体封装**：定义 struct LinkedList { Node* head; Node* tail; }。
    
3. **维护成本**：
    
    - 陷阱：删除最后一个节点时，不仅要断链，还要更新 tail 指针（这是最容易出 Bug 的地方）。
        

---

## 第四阶段：复杂形态 —— 循环与双向

**目标**：掌握能够双向游走的高级链表，解决更复杂的问题。

### 第 8 课：循环链表（Circular List）

1. **闭环结构**：尾节点的 next 指向头节点（或哨兵）。
    
2. **约瑟夫环问题（Josephus Problem）**：
    
    - 循环链表的典型应用。
        
    - 如何判断循环结束？（p->next == p）。
        
3. **无限循环陷阱**：如何避免打印链表时死循环。
    

### 第 9 课：双向链表基础（Doubly Linked List）

1. **结构定义**：增加 prior（前驱）指针。
    
2. **操作优势**：
    
    - 自我删除：node 可以直接找到前驱，不需要遍历。
        
    - 双向遍历：可以从后往前打印。
        
3. **操作代价**：插入和删除需要修改 4 个指针，顺序不能乱。
    

### 第 10 课：终极形态 —— 双向双哨兵

1. **Head & Tail Sentinels**：链表永远以 `[Head]` 开始，以 [Tail] 结束。
    
2. **无死角逻辑**：
    
    - 插入：永远是在 p 和 p->next 之间插入。
        
    - 删除：永远存在前驱和后继。
        
    - 无需任何 NULL 检查（除了遍历结束）。
        
3. **实战代码**：编写一套通用的、工业级的 List 库。
    

---

## 第五阶段：综合实战与调试技巧

**目标**：将知识转化为解决问题的能力。

### 第 11 课：调试与防错

1. **段错误（Segmentation Fault）大全**：
    
    - 试图访问 NULL->next。
        
    - 访问已被 free 的内存。
        
2. **内存泄漏检测**：
    
    - 如何编写 DestroyList 函数彻底清理内存。
        
    - 使用工具（如 Valgrind，如果环境允许）或手动计数法检测泄漏。
        

### 第 12 课：经典算法题突破

1. **反转链表**：迭代法 vs 递归法。
    
2. **快慢指针技巧**：
    
    - 判断链表是否有环。
        
    - 寻找链表中点。
        
3. **合并两个有序链表**。
    
4. **LRU 缓存设计**：结合哈希表和双向哨兵链表（大厂面试高频题）。