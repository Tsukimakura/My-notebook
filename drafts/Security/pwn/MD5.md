## 基本概念

**MD5**（Message-Digest Algorithm 5）是一种广泛使用的密码散列函数，生成128位（32字符）的"数字指纹"

## 核心特性

- **固定输出**：任意输入 → 固定32位十六进制字符串
    
- **确定性**：相同输入永远产生相同输出
    
- **雪崩效应**：微小输入变化 → 巨大输出差异
    
- **快速计算**：适合大数据量处理
    

## 算法输出示例

```text
"hello" → 5d41402abc4b2a76b9719d911017c592
"hellp" → 完全不同但固定长度的哈希值
```
## 原始用途

- 数据完整性校验（文件下载验证）
- 密码存储（**现已不安全**）

## 安全性问题

### 已证实漏洞

1. **碰撞攻击**：可人为制造不同内容但MD5相同的文件
2. **快速破解**：彩虹表、暴力破解效率极高
3. **不再适合**：密码存储、数字签名等安全场景

## CTF 常见考点

### 1. 弱类型比较漏洞

```php

// PHP 松散比较 ==
if ($_GET['a'] != $_GET['b'] && md5($_GET['a']) == md5($_GET['b'])) {
    // 获取flag
}

**利用方法**：使用`0e`开头的MD5值

- `QNKCDZO` → `0e830400451993494058024219903391`
    
- `240610708` → `0e462097431906509019562988736854`
    
```
### 2. 强类型比较与碰撞

```php
// PHP 严格比较 ===
if ($_GET['a'] !== $_GET['b'] && md5($_GET['a']) === md5($_GET['b'])) {
    // 需要真正的MD5碰撞
}

**工具**：`fastcoll` 生成碰撞对
```
### 3. 数组绕过

```php
if (md5($_GET['a']) == md5($_GET['b'])) {
    // 获取flag
}

**Payload**：`a[]=1&b[]=2`  
**原理**：`md5(array)` 返回 `NULL`
```
## 实用命令

### 计算MD5值

```bash
# Linux/WSL - 注意 -n 参数避免换行符
echo -n "hello" | md5sum

# 计算文件MD5
md5sum filename.txt

# 只获取哈希值（去除输入源标识，只输出纯MD5）
echo -n "text" | md5sum | cut -d' ' -f1
```
### Python 计算

```python
import hashlib
text = "hello"
result = hashlib.md5(text.encode()).hexdigest()
print(result)  # 5d41402abc4b2a76b9719d911017c592
```
## 现代替代方案

|算法|输出长度|安全性|
|---|---|---|
|MD5|128位|❌ 已破解|
|SHA-256|256位|✅ 目前安全|
|SHA-3|可变|✅ 目前安全|
cmd5.com可以在线解密md5